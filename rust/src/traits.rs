//! `traits.rs`: traits supporting a common `XSTREAM` API over multiple
//! different combinations of algorithms.

use error::Error;
use rand::Rng;

/// `XSTREAM` encryptor object: encrypts message streams by sealing them under
/// a given public key.
pub trait Encryptor {
    /// Public key type used by this `XSTREAM`
    type PublicKey;

    /// Create a new STREAM `Encryptor` object which seals a stream of messages
    /// under the given public key. Only the holder of the corresponding secret
    /// key for the public key will be able to decrypt them.
    ///
    /// Returns a STREAM `Encryptor` object along with an ephemeral public key
    /// which was used to seal the message. This same ephemeral public key must
    /// be provided to the `Decryptor` in order to successfully decrypt the
    /// message.
    ///
    /// An optional salt value can be provided, which will be used as an input
    /// to the ECIES key derivation function, but is not strictly necessary
    /// as Encryptor objects will generate a random ECDH keypair as part of
    /// the encryption process, ensuring all message streams are encrypted
    /// under a random key.
    fn new<T: Rng>(
        csprng: &mut T,
        public_key: &Self::PublicKey,
        salt: Option<&[u8]>,
    ) -> (Self, Self::PublicKey)
    where
        Self: Sized;

    /// Encrypt the next message in the stream in-place
    fn seal_next_in_place(&mut self, ad: &[u8], buffer: &mut [u8]);

    /// Encrypt the final message in-place, consuming the stream encryptor
    fn seal_last_in_place(self, ad: &[u8], buffer: &mut [u8]);

    /// Encrypt the next message in the stream, allocating and returning a
    /// `Vec<u8>` for the ciphertext
    fn seal_next(&mut self, ad: &[u8], plaintext: &[u8]) -> Vec<u8>;

    /// Encrypt the final message in the stream, allocating and returning a
    /// `Vec<u8>` for the ciphertext
    fn seal_last(self, ad: &[u8], plaintext: &[u8]) -> Vec<u8>;
}

/// `XSTREAM` decryptor object: decrypts message streams which were encrypted
/// under the public key which corresponds to the private key being passed
/// to the decryptor.
pub trait Decryptor {
    /// Private key type used by this `XSTREAM`
    type PrivateKey;

    /// Public key type used by this `XSTREAM`
    type PublicKey;

    /// Create a new Decryptor object which unseals a stream of messages
    /// which were previously encrypted using the public key that cooresponds
    /// to the given private key.
    ///
    /// Additionally, the ephemeral public key generated by the `Encryptor`
    /// (returned from `Encryptor::new`) must be provided for decryption to
    /// succeed.
    ///
    /// An optional salt value can be provided, which will be used as an
    /// input to the ECIES key derivation function. If provided, it MUST be
    /// the same as the salt value used to seal the messages originally,
    /// or decryption will fail.
    fn new(
        private_key: &Self::PrivateKey,
        ephemeral_key: &Self::PublicKey,
        salt: Option<&[u8]>,
    ) -> Self;

    /// Decrypt the next message in the stream in-place
    fn open_next_in_place<'a>(
        &mut self,
        ad: &[u8],
        buffer: &'a mut [u8],
    ) -> Result<&'a [u8], Error>;

    /// Decrypt the final message in-place, consuming the stream decryptor
    fn open_last_in_place<'a>(self, ad: &[u8], buffer: &'a mut [u8]) -> Result<&'a [u8], Error>;

    /// Decrypt the next message in the stream, allocating and returning a
    /// `Vec<u8>` for the plaintext
    fn open_next(&mut self, ad: &[u8], ciphertext: &[u8]) -> Result<Vec<u8>, Error>;

    /// Decrypt the next message in the stream, allocating and returning a
    /// `Vec<u8>` for the plaintext
    fn open_last(self, ad: &[u8], ciphertext: &[u8]) -> Result<Vec<u8>, Error>;
}
